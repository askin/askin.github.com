--- 
layout: post
title: "Sezar \xC5\x9Fifreleme"
published: true
meta: 
  _edit_last: "1"
  _sexybookmarks_permaHash: 6d605b5fcb7bdb233c9ad7d818f1a3eb
  _sexybookmarks_shortUrl: http://goo.gl/uAGSq
tags: 
- Algoritma
- Programlama
- Scheme
- Sezar
- "\xC5\x9Eifreleme"
type: post
status: publish
---
Sezar şifreleme için yazdığım ilk kod aşağıdaki gibiydi 
<pre lang="scheme" lineno="0">(define str2 "")
(define (sezar str lst)
  (do ((i 0 (+ i 1)) (j 0 (+ j 1))) ((= j (string-length str)))
    (if (= i (length lst))
        (set! i 0))
    (set! str2 
          (string-append
           str2
           (string (integer->char
                    (+ (list-ref lst i )
                       (char->integer (string-ref str j)))))))))</pre>

Ancak bu kod pek hoşuma gitmedi üzerinde biraz daha oynama yapmak gerekiyordu. Mesela en baştaki <pre lang="scheme">(define str2 "")</pre> pek hoş durmuyordu ve hiç bir sonuç gönmüyordu. Ekstradan srt2 nin değerini sorgulamak gerekiyordu.
<!--more-->
Bu sebeple kodu aşağıdaki hale getirdim.
<pre lang="scheme" lineno="0"> (define (sezar str lst)
  (let ((str (string-downcase str)) (str2 ""))
  (do ((i 0 (+ i 1)) (j 0 (+ j 1))) ((= j (string-length str)))
    (if (= i (length lst))
        (set! i 0))
    (set! str2 
          (string-append
           str2 
           (string (integer->char
                    (+ (list-ref lst i )
                       (char->integer (string-ref str j))))))))
    (values str2)))</pre>

Ancak yine eksiklikler vardı. <pre lang="scheme">(sezar "zeliha" '(1 2))</pre> bize "{gmkic" değerini döndürüyordu. "agmkic" gibi bir değer bizim için daha hoş olabilirdi. 
<pre lang="scheme" lineno="0">(define (sezar str lst)
  (let ((str (string-downcase str)) (str2 "") (tmp 0))
  (do ((i 0 (+ i 1)) (j 0 (+ j 1))) ((= j (string-length str)))
    (if (= i (length lst))
        (set! i 0))
    (set! str2 
          (string-append
           str2 
           (string (integer->char
                    (begin
                      (set! tmp (+ (list-ref lst i )
                       (char->integer (string-ref str j))))
                      (cond
                        [(> tmp 122) (- tmp 26)]
                        [else tmp])))))))
    (values str2)))</pre>
Burda eklediğim satırlar karaktere çevirilecek sayının değerinin 122den büyük olup olmadığını kontrol ediyor. Eğer z+1=123 gibi bir değer elde ederse bu değer a'ya çevirliyor. 
Kodlara <a href="http://www.askin.ws/doc/sezar.scm">Burdan</a> ulaşabilirsiniz.
